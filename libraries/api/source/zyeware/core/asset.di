// This file was generated by ZyeWare APIgen. Do not edit!
module zyeware.core.asset;


import std.string : format;
import std.exception : collectException, assumeWontThrow, enforce;
import std.typecons : Tuple;
import std.traits : fullyQualifiedName;
import zyeware;
import zyeware.core.weakref;

/// UDA to mark an asset to be loaded.
struct asset {

Flag!"cache" cache;
}
private template isAsset(E) {
import std.traits : hasUDA;

static if (__traits(compiles, hasUDA!(E, asset)))

enum bool isAsset;else

enum bool isAsset;
}

/// Responsible for loading assets into memory. It caches all loaded assets, therefore
/// it will not invoke a loader again as long as the reference in memory is valid.
/// The `AssetManager` will only keep weak references, e.g. it will not keep an unused
/// asset from being collected by the GC.
struct AssetManager {

@disable this();

@disable this(this);

private static:

struct AssetUID {

string typeFQN;

string path;
}
alias LoadCallback = Object function(string);
alias LoadFunction = Tuple!(LoadCallback, "callback", bool, "cache");

LoadFunction[string] sLoaders;

WeakReference!Object[AssetUID] sCache;

Object load(in AssetUID uid);

void register(string fqn, LoadCallback callback, bool cache);

bool unregister(string fqn);

bool isCached(in AssetUID uid) nothrow;

package(zyeware.core) static:

void initialize();

void cleanup();

public static:

/// Load the asset at the given path into memory, optionally with a pre-defined
/// loader format.
/// 
/// Params:
/// path = The path of the file to load.
/// T = The type of Asset to load.
/// 
/// Returns: The loaded asset.
pragma(inline, true) T load(T)(string path) 
if(isAsset!T)
in (path, "Path cannot be null.") {
return cast(T)load(AssetUID(fullyQualifiedName!T, path));
}

/// Registers a new asset.
/// 
/// Params:
/// T = The asset type to register.
void register(T)(LoadCallback callback) 
if(isAsset!T) {
import std.traits : getUDAs;

auto data = getUDAs!(T, asset)[0];;
register(fullyQualifiedName!T, callback, data.cache);
}

/// Unregisters an asset.
/// 
/// Params:
/// T = The asset type to unregister.
/// 
/// Returns: If the loader has been removed.
bool unregister(T)() 
if(isAsset!T) {
return unregister(fullyQualifiedName!T);
}

/// Checks if the given file is already cached.
/// 
/// Params:
/// T = The type of asset.
/// path = The path of the file to check.
bool isCached(T)(string path) nothrow 
if(isAsset!T)
in (path, "Path cannot be null.") {
return isCached(AssetUID(fullyQualifiedName!T, path));
}

/// Destroys all cached assets.
void freeAll();

/// Cleans the cache from assets that have already been garbage collected.
void cleanCache() nothrow;
}