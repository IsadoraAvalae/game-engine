// This file was generated by ZyeWare APIgen. Do not edit!
module zyeware.core.interpolator;


import std.algorithm : remove, sort, clamp;
import std.typecons : Tuple;
import zyeware;
import zyeware.utils.sdlang;

alias Interpolatorf = Interpolator!(float, lerp!float);
alias Interpolatord = Interpolator!(double, lerp!double);

/// The `Interpolator` allows to create various keypoints on a 
/// one dimensional line, and interpolating between them.
/// You can supply a custom type and lerping function for various
/// different types.
struct Interpolator(T, alias lerp) {

protected:
alias Point = Tuple!(float, "offset", T, "value");

Point[] mPoints;

bool mMustSortPoints;

public:

/// Add a keypoint to the interpolator with the given offset and value.
/// Params:
/// offset = The offset of the keypoint.
/// value = The value of the keypoint.
void addPoint(float offset, const T value) pure nothrow;

/// Removes a keypoint with the given index.
void removePoint(size_t idx) pure nothrow;

/// Removes all keypoints from this interpolator.
void clearPoints() pure nothrow;

/// Interpolates a value from the keypoints in this interpolator from the given offset.
/// Params:
/// offset = The offset to use.
/// Returns: The interpolated value.
T interpolate(float offset) pure nothrow;

staticauto load(string path);
}

@("Interpolator") unittest {
import unit_threaded.assertions;

Interpolatorf interpolator;
interpolator.addPoint(0.0f, 0.0f);
interpolator.addPoint(1.0f, 1.0f);
interpolator.addPoint(0.5f, 0.5f);
interpolator.mPoints.length.should == 3;
interpolator.removePoint(1);
interpolator.mPoints.length.should == 2;
interpolator.clearPoints();
interpolator.mPoints.length.should == 0;
interpolator.addPoint(0.0f, 0.0f);
interpolator.addPoint(1.0f, 1.0f);
interpolator.addPoint(0.5f, 0.5f);
interpolator.mPoints.length.should == 3;
interpolator.interpolate(0.25f).should == 0.25f;
interpolator.interpolate(0.75f).should == 0.75f;
}