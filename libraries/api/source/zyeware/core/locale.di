// This file was generated by ZyeWare APIgen. Do not edit!
module zyeware.core.locale;


import std.variant : Variant;
import std.array : Appender;
import std.string : format, startsWith, join, indexOf;
import std.exception : enforce, assumeWontThrow;
import std.conv : to;
import zyeware;

/// Translates a key.
alias tr = LocaleManager.translate;

/// Responsible for managing loaded locales and translating requests.
struct LocaleManager {

private static:

Locale[string] sLoadedLocales;

Locale sActiveLocale;

public static:

/// Translates a key.
/// 
/// Params:
/// key = The key to translate.
/// 
/// Returns: The translated string, or `key` if it couldn't be translated.
string translate(string key, Variant[string] args = null) nothrow;

/// Registers a locale to the manager. If the given locale is already registered, then
/// the new translation gets merged into the existing one.
/// 
/// Params:
/// file = The translation file to register. The locale is stored inside of it.
/// 
/// See_Also: Translation
void addLocale(Locale file) nothrow;

/// Unregisters a locale from the manager.
/// 
/// Params:
/// locale = The locale name to unregister.
void removeLocale(string locale) nothrow;

/// All currently loaded locales.
string[] allLocales() nothrow;

/// The currently active locale.
string locale() nothrow;

/// ditto
void locale(string locale);
}

@asset(Yes.cache) class Locale {

protected:

string mLocale;

Translation[string] mTranslations;

public:

/// Params:
/// locale = The ISO 639-1 name for the language.
/// translations = Key-to-language translations in an AA.
/// assetRemaps = The resource remaps in an AA.
this(string locale)
in (locale, "Locale cannot be null.") {
mLocale = locale;
}

/// Adds a key with the corresponding translation to the locale.
/// 
/// Params:
/// key = The key.
/// translation = The translation it should correspond to.
void addTranslation(string key, Translation translation) nothrow;

/// Removes a translation from the locale.
/// 
/// Params:
/// key = The key of the translation to remove.
void removeTranslation(string key) nothrow;

/// Tries to optimize all further key lookups.
void optimize() nothrow;

/// Translates a key to it's specified translation.
/// 
/// Params:
/// key = The key of the translation to fetch.
/// 
/// Returns: The translation, or `key` if it doesn't exist.
string translate(string key, Variant[string] args = null) const nothrow;

/// The ISO 639-1 name of this locale.
string locale() const nothrow;

/// Loads and returns a `Translation` instance from the given file.
/// 
/// Params:
/// path = The path of the file to load.
static Locale load(string path);
}

enum Plurality 
 {
zero,
one,
two,
few,
many,
other
}

private:

abstract class Translation {

public:

abstract string get(Variant[string] args) const nothrow;
}

final class LiteralTranslation : Translation {

private:

string mText;

public:

this(string text)
in (text, "Text cannot be null.") {
mText = text;
}

override string get(Variant[string] args) const nothrow;
}

final class PlaceholderTranslation : Translation {

private:

struct TextNode {

bool isPlaceholder;

string value;
}

TextNode[] mNodes;

void parse(string text) nothrow;

public:

this(string text)
in (text, "Text cannot be null.") {
parse(text);
}

override string get(Variant[string] args) const nothrow;
}

final class PluralTranslation : Translation {

private:

Translation[Plurality] mTranslations;

public:

this(Translation[Plurality] translations)
in (translations, "Translations cannot be null.")
in (Plurality.other in translations, "Translations must contain 'other'.") {
mTranslations = translations;
}

override string get(Variant[string] args) const nothrow;
}