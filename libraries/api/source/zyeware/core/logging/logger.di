// This file was generated by ZyeWare APIgen. Do not edit!
module zyeware.core.logging.logger;


import core.stdc.stdio : printf;
import std.stdio : File, stdout;
import std.datetime : Duration;
import std.string : fromStringz;
import std.traits : isSomeString;
import std.algorithm : remove, SwapStrategy;
import std.conv : dtext;
import zyeware;

/// The log level to use for various logs.
enum LogLevel 
 {
off, /// No logs should go through. This is only useful for setting a "minimum log level."

fatal, /// Extremely severe incidents which almost certainly are followed by a crash.

error, /// Severe incidents that can impact the stability of the application.

warning,
info,
debug_,
verbose /// Used when logging very minute details.

}

private immutable dstring[] levelNames;

/// Represents a single logger.
final class Logger {

private:

LogSink mSink;

LogLevel mLogLevel;

dstring mName;

public:

/// Params:
/// sink = The log sink to use for writing messages.
/// logLevel = The minimum log level that should be logged.
/// name = The name of the logger.
this(LogSink sink, LogLevel logLevel, dstring name) pure nothrow {
mSink = sink;
mLogLevel = logLevel;
mName = name;
}

/// Writes a message to this log.
/// Params:
/// level = The log level the message should be written as.
/// message = The message itself.
void log(LogLevel level, dstring message) nothrow;

/// Flushes the log sink connected to this log.
void flush();
}

/// Represents a sink to write a message into. This can be either a file, a console,
/// a in-game display, etc.
abstract class LogSink {

public:

/// The data that should be logged.
struct LogData {

dstring loggerName;

LogLevel level;

Duration uptime;

dstring message;
}

/// Logs the given data.
/// Params:
/// data = The data to log.
abstract void log(in LogData data);

/// Flushes the current sink.
abstract void flush();
}

final class CombinedLogSink : LogSink {

private:

LogSink[] mSinks;

public:

/// Params:
/// sinks = The sinks to combine.
this(LogSink[] sinks) {
mSinks = sinks;
}

/// Add a log sink to this logger.
void addSink(LogSink sink) @trusted pure;

/// Remove the specified log sink from this logger.
/// If the given sink doesn't exist, nothing happens.
/// Params:
/// sink = The sink to remove.
void removeSink(LogSink sink) @trusted;

override void log(in LogData data);

override void flush();
}

/// Represents a log sink that logs into a real file.
class FileLogSink : LogSink {

protected:

File mFile;

public:

/// Params:
/// file = The file to log into.
this(File file) {
mFile = file;
}

override void log(in LogData data);

override void flush();
}

/// Represents a sink that writes in modulate to stdout.
class ColorLogSink : LogSink {
import consolecolors;

public:

override void log(in LogData data);

override void flush();
}