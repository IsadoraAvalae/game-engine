// This file was generated by ZyeWare APIgen. Do not edit!
module zyeware.rendering.image;


import std.string : format;
import std.exception : enforce;
static import gamut;
import zyeware;

@asset(Yes.cache) class Image {

protected:

const(ubyte[]) mPixels;

ubyte mChannels;

ubyte mBitsPerChannel;

vec2i mSize;

public:

this(in ubyte[] pixels, ubyte channels, ubyte bitsPerChannel, vec2i size) pure nothrow
in (size.x > 0 && size.y > 0, "Image must be at least 1x1.")
in (pixels && pixels.length == size.x * size.y * channels * (bitsPerChannel / 8), "Invalid amount of pixels.")
in (channels > 0 && channels <= 4, "Invalid amount of channels.")
in (bitsPerChannel >= 8 && bitsPerChannel <= 32, "Invalid amount of bits per channel.") {
mPixels = pixels;
mChannels = channels;
mBitsPerChannel = bitsPerChannel;
mSize = size;
}

color getPixel(vec2i coords) pure const nothrow;

const(ubyte[]) pixels() pure const nothrow;

ubyte channels() pure const nothrow;

ubyte bitsPerChannel() pure const nothrow;

vec2i size() pure const nothrow;

static Image load(string path);

static Image load(in ubyte[] data);
}

@("Image") unittest {
import unit_threaded.assertions;

immutable ubyte[] pixels;

ubyte channels;

ubyte bitsPerChannel;

vec2i size;

Image image;
image.pixels.length.should == 8;
image.channels.should == 4;
image.bitsPerChannel.should == 8;
image.size.x.should == 2;
image.size.y.should == 1;
image.getPixel(vec2i(0, 0)).should == color(0, 0, 0, 1);
image.getPixel(vec2i(1, 0)).should == color(1, 1, 1, 1);
image.getPixel(vec2i(2, 0)).should == color(1, 0, 1, 1);
}