// This file was generated by ZyeWare APIgen. Do not edit!
module zyeware.utils.collection;


import std.traits : hasIndirections, isDynamicArray;
import std.algorithm : countUntil, remove;

/// A growable circular queue represents a FIFO collection that,
/// except if it needs to grow, doesn't allocate and free memory
/// with each push and pop.
struct GrowableCircularQueue(T) {

private:

size_t mLength;

size_t mFirst, mLast;

T[] mArray;

public:

/// Params:
/// items = The items to initialise this queue with.
this(T[] items...) pure nothrow {

foreach (x; items)
push(x);
}

/// Whether the collection is empty.
bool empty() pure const nothrow;

/// Returns the front element of the queue.
inout(T) front() pure inout nothrow;

/// Returns the n-th element of the queue, starting from 0.
inout(T) opIndex(in size_t i) pure inout nothrow;

/// Pushes an item into the queue. Can cause a growth and allocation
/// if there is not enough space.
/// Params:
/// item = The item to push into the queue.
void push(T item) pure nothrow;

/// Pops the front-most item from the queue.
T pop() pure nothrow;

/// The length of the queue.
size_t length() pure const nothrow;
}

struct GrowableStack(T) {

private:

size_t mNextPointer;

T[] mArray;

public:

this(size_t initialSize) pure nothrow {
mArray.length = initialSize;
}

bool empty() pure const nothrow;

inout(T) peek() pure inout nothrow;

inout(T) opIndex(size_t i) pure inout nothrow;

void push(T item) pure nothrow;

T pop() pure nothrow;

size_t mLength() pure const nothrow;

void mLength(size_t value) pure nothrow;
}

auto removeElement(R, N)(R haystack, N needle) 
if(isDynamicArray!R) {

auto index = haystack.countUntil(needle);;
return (index != -1) ? haystack.remove(index) : haystack;
}