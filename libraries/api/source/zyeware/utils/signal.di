// This file was generated by ZyeWare APIgen. Do not edit!
module zyeware.utils.signal;


import std.algorithm : remove;
import zyeware;

struct Signal(T1...) {

private:
alias delegate_t = void delegate(T1) nothrow;
alias function_t = void function(T1) nothrow;

struct Slot {

union  {

delegate_t dg;

function_t fn;
}

bool isDelegate;

bool isOneShot;
}

Slot[] mSlots;

ptrdiff_t findSlot(delegate_t dg) @trusted pure nothrow;

ptrdiff_t findSlot(function_t fn) @trusted pure nothrow;

public:

void connect(delegate_t dg, Flag!"oneShot" oneShot = No.oneShot) @trusted pure;

void connect(function_t fn, Flag!"oneShot" oneShot = No.oneShot) @trusted pure;

void disconnect(delegate_t dg) @trusted pure nothrow;

void disconnect(function_t fn) @trusted pure nothrow;

void disconnectAll() @safe pure nothrow;

void emit(T1 args) nothrow;pragma(inline, true)  {

void opCall(T1 args);

void opOpAssign(string op)(delegate_t dg) 
if(op == "~")=> connect(dg);

void opOpAssign(string op)(function_t fn) 
if(op == "~")=> connect(fn);

void opOpAssign(string op)(delegate_t dg) 
if(op == "-")=> disconnect(dg);

void opOpAssign(string op)(function_t fn) 
if(op == "-")=> disconnect(fn);
}
}

@("Signals") unittest {
import unit_threaded.assertions;

Signal!int signal;

int result;

void delegate(int x) nothrow delegate1;

void function(int x) nothrow function1;
signal.connect(delegate1);
signal.mSlots.length.should == 1;
signal.connect(function1);
signal.mSlots.length.should == 2;
signal.emit(20);
result.should == 20;
signal.disconnect(delegate1);
signal.mSlots.length.should == 1;
signal.disconnect(function1);
signal.mSlots.length.should == 0;
signal.connect(delegate1);
signal.connect(function1);
signal.mSlots.length.should == 2;
signal.connect(delegate1).shouldThrow;
signal.connect(function1).shouldThrow;
signal.connect(cast(signal.delegate_t)null).shouldThrow;
signal.connect(cast(signal.function_t)null).shouldThrow;
signal.disconnectAll();
signal.mSlots.length.should == 0;
}