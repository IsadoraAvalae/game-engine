module apigen.generator;

import std.path : baseName;
import std.array : Appender;
import std.algorithm : remove;

import consolecolors;

import dparse.ast;
import dparse.lexer;
import dparse.parser;
import dparse.rollback_allocator;
import dparse.formatter;

class InterfaceFileGenerator
{
protected:
    PreparationVisitor visitor = new PreparationVisitor();

public:
    LexerConfig lexerConfig;
    RollbackAllocator allocator;

    string generate(string source)
    {
        auto cache = StringCache(StringCache.defaultBucketCount);
        
        auto tokens = getTokensForParser(source, lexerConfig, &cache);
        auto mod = parseModule(tokens, "<gen>", &allocator);

        visitor.visit(mod);

        Appender!string output;
        output.put("// This file was generated by ZyeWare APIgen. Do not edit!");
        auto formatter = new Formatter!(Appender!string)(output, false, IndentStyle.otbs, 0);
        formatter.format(mod);

        return output[];
    }
}

final class PreparationVisitor : ASTVisitor
{
private:
    bool isExposable(const(Declaration) decl)
    {
        bool hasExposeAttribute = false;
        bool hasPragma = false;

        foreach (const(Attribute) attr; decl.attributes)
        {
            if (attr.atAttribute && attr.atAttribute.identifier.text == "expose")
                hasExposeAttribute = true;

            if (attr.pragmaExpression)
                hasPragma = true;
        }

        return hasExposeAttribute && !hasPragma;
    }

    void removeUselessAttributes(Declaration decl)
    {
        for (size_t i; i < decl.attributes.length; i++)
        {
            const(Attribute) attr = decl.attributes[i];

            if ((attr.atAttribute && attr.atAttribute.identifier.text == "expose"))
            {
                decl.attributes = decl.attributes.remove(i--);
            }
        }
    }

public:
    alias visit = ASTVisitor.visit;

    override void visit(const Module mod)
    {
        auto mutMod = cast() mod;

        for (size_t i; i < mutMod.declarations.length; i++)
        {
            const(Declaration) decl = mutMod.declarations[i];

            if (!isExposable(decl))
                mutMod.declarations = mutMod.declarations.remove(i--);
            else
                removeUselessAttributes(cast() decl);
        }

        mod.accept(this);
    }

    override void visit(const StructBody body_)
    {
        auto mutBody = cast() body_;

        for (size_t i; i < mutBody.declarations.length; i++)
        {
            const(Declaration) decl = mutBody.declarations[i];

            if (!isExposable(decl))
                mutBody.declarations = mutBody.declarations.remove(i--);
            else
                removeUselessAttributes(cast() decl);
        }

        body_.accept(this);
    }

    override void visit(const FunctionDeclaration func)
    {
        // Only remove function body from functions that have no templates
        if (!func.templateParameters)
        {
            auto mutFunc = cast() func;
            mutFunc.functionBody = null;
        }

        func.accept(this);
    }
}